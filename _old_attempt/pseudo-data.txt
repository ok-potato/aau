abstract class Term:
	int name

class ProximityRelation:
	# must ensure correspondence relation for this
	# additionally, store inverse explicitly
	# identity mapping exists implicitly
	HashMap<Integer, HashMap<Integer, ArgumentRelation>> proximityMapping

	ArgumentRelation getRelation(int left, int right):
		return proximityMapping.get(left).get(right)


class ArgumentRelation:
	# consider making this ArrayList<int[]> map
	int[][] argumentMapping
	float beta


# compound term
class Function extends Term:
	Term[] arguments
	HashSet<Variable> var
   
	public Function(Term[] arguments):
		this.terms = terms
		
		var = new HashSet<Variable>
		for (Term t in this.arguments):
			if t instanceof Variable:
				var.add((Variable) t)
			else:
				for (Variable v in var((Function) t)):
					var.add(v)


# variable term
class Variable extends Term:
	

class UEquation:
	Term left, right

class UConfiguration:
	# duplicates are not allowed, hashsets are a fast way of insuring this
	# equations of the form x =? f
	HashSet<UEquation> funEquations
	# equations of the form x =? y
	HashSet<UEquation> varEquations
	Substitution sigma
	float alpha
	
	
	
	
	
		